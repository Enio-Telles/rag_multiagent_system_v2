import json
import pandas as pd
import sys
from pathlib import Path

# Adicionar o diret√≥rio src ao path
src_path = Path(__file__).parent / "src"
sys.path.append(str(src_path))

from config import Config
from ingestion.data_loader import DataLoader

class DebugKnowledgeBaseBuilder:
    def __init__(self):
        self.config = Config()
        self.data_loader = DataLoader()
        self.ncm_hierarchy = {}
    
    def _normalize_ncm(self, ncm_code: str) -> str:
        """Normaliza c√≥digo NCM removendo pontos e espa√ßos."""
        return str(ncm_code).replace(".", "").replace(" ", "").strip()
    
    def _build_ncm_hierarchy(self, ncm_data: list):
        """Constr√≥i hierarquia de NCMs para permitir busca por c√≥digos parciais."""
        for item in ncm_data:
            code = self._normalize_ncm(item.get("C√≥digo", ""))
            if code:
                self.ncm_hierarchy[code] = {
                    "codigo_original": item.get("C√≥digo", ""),
                    "descricao_completa": item.get("Descricao_Completa", "").strip(),
                    "nivel": len(code)
                }
    
    def _find_best_ncm_match(self, ncm_input: str) -> str:
        """Encontra o melhor match NCM considerando hierarquia."""
        normalized_input = self._normalize_ncm(ncm_input)
        
        print(f"üîç Buscando match para: '{ncm_input}' ‚Üí normalizado: '{normalized_input}'")
        
        # Primeiro, tenta match exato
        if normalized_input in self.ncm_hierarchy:
            print(f"‚úÖ Match exato encontrado: {normalized_input}")
            return normalized_input
        
        # Se n√£o encontrar exato, busca c√≥digos que come√ßam com o input (mais espec√≠ficos)
        matches_especificos = []
        for code in self.ncm_hierarchy:
            if code.startswith(normalized_input) and len(code) >= len(normalized_input):
                matches_especificos.append(code)
        
        if matches_especificos:
            print(f"üéØ Matches espec√≠ficos encontrados: {matches_especificos[:5]}...")
            return matches_especificos[0]
        
        # Se n√£o encontrar mais espec√≠ficos, busca c√≥digos que o input come√ßa (mais gerais)
        for length in range(len(normalized_input) - 1, 0, -1):
            partial_code = normalized_input[:length]
            if partial_code in self.ncm_hierarchy:
                print(f"üìà Match hier√°rquico encontrado: {partial_code}")
                return partial_code
        
        print(f"‚ùå Nenhum match encontrado para: {normalized_input}")
        return None

# Executar debug
debug = DebugKnowledgeBaseBuilder()

# Carregar hierarquia NCM
ncm_data = debug.data_loader.load_ncm_descriptions()
if ncm_data:
    debug._build_ncm_hierarchy(ncm_data)
    print(f"Hierarquia carregada: {len(debug.ncm_hierarchy)} c√≥digos")
    
    # Testar busca para "3004"
    result = debug._find_best_ncm_match("3004")
    print(f"Resultado final: {result}")
    
    # Verificar se 3004 existe na hierarquia
    if "3004" in debug.ncm_hierarchy:
        print(f"‚úÖ 3004 existe na hierarquia: {debug.ncm_hierarchy['3004']}")
    else:
        print("‚ùå 3004 N√ÉO existe na hierarquia")
        
        # Verificar c√≥digos pr√≥ximos
        proximos = [code for code in debug.ncm_hierarchy.keys() if code.startswith("300")]
        print(f"C√≥digos pr√≥ximos (300*): {sorted(proximos)[:10]}")
